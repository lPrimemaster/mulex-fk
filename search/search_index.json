{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mulex Framework Brief","text":"<p>Multiple Experiment Framework (mulex-fk) is a realtime service manager for multiporpuse experiment control. It allows for TCP/IP communication for multiple backends and frontends. As long as your machines have ethernet connection between one another they can seemlessly view each other's data in realtime.</p>"},{"location":"#main-features","title":"Main Features","text":"<ul> <li>Platform native TCP/IP allowing for high speed and bandwith communication</li> <li>Backend isolation</li> <li>Webapp visualization frontend without any instalation required</li> <li>Realtime database that allows for a seemless interchange of data between backends and/or frontends</li> <li>Persistent sqlite database for configurations or other permanent data</li> <li>Data events</li> <li>Message logging</li> <li>Frontend data over websocket allows to transfer bulk data such as for visualizing realtime plots/images</li> <li>Backend API written in C++ but extensible for any language as long as the same protocol is supported</li> <li>Frontend API written in typescript but again extensible</li> <li>Out of the box support for USB/TCP/Serial drivers for backends</li> <li>Low CPU impact</li> <li>Backend remote start/stop</li> </ul>"},{"location":"#upcoming-features","title":"Upcoming Features","text":"<ul> <li>Event timeline view</li> <li>Alarms</li> </ul>"},{"location":"backends/","title":"Backends","text":""},{"location":"backends/#summary","title":"Summary","text":"<p>The <code>mulex::MxBackend</code> is where the users can write their system drivers to control any device that might be connected to the system. Backends can also be used to gather data from other backends and analyze them.</p> <p>Each backend runs its own event loop and the user can register timed functions. For those who are familiar with javascript, something like <code>setInterval</code> and <code>setTimeout</code>.</p> <p>Tasks that can be performed from within a backend context include:</p> <ul> <li>Reading/Writing to the RDB</li> <li>Reading/Writing to the PDB</li> <li>Dispatching/Subscribing to events</li> <li>Declare a user RPC function that can be called from other contexts (backends or plugins)</li> <li>Sending logs to the frontend</li> <li>Registering user functions that act as data gathering (e.g. periodic, on trigger, ...)</li> <li>Remote launch other backends that are marked as dependencies</li> </ul> <p>Other than that, a backend is a standalone C++ executable that can run any type of logic the user pretends.</p>"},{"location":"backends/#using-backends","title":"Using Backends","text":"<p>A backend is a C++ object that derives from the <code>mulex::MxBackend</code> class.</p> <p>Here is the minimum required boilerplate code to create a user backend.</p> <pre><code>#include &lt;mxbackend.h&gt;\n\nclass MyBackend : public mulex::MxBackend\n{\npublic:\n    MyBackend(int argc, char* argv[]) : mulex::MxBackend(argc, argv)\n    {\n        // User init goes here all communication is valid here\n        // e.i. rdb, pdb, logging, events\n    }\n};\n\nint main(int argc, char* argv[])\n{\n    MyBackend bck(argc, argv);\n    bck.init();\n    bck.spin();\n    return 0;\n}\n</code></pre> <p>This backend would compile and connect to the <code>mxmain</code> server. However it wouldn't do much. We can run this backend via <code>./MyBackend --server &lt;mxmain_ip&gt;</code>.</p>"},{"location":"backends/#backend-rdb","title":"Backend RDB","text":"<p>To access the RDB in a backend the user can use the <code>rdb</code> protected member.</p> <p>For more info see here.</p>"},{"location":"backends/#backend-pdb","title":"Backend PDB","text":"<p>Accessing the PDB is similar via using the <code>pdb</code> protected member.</p> <p>For more info see here.</p>"},{"location":"backends/#backend-logging","title":"Backend Logging","text":"<p>The mx system supports logging. It is done via the <code>log</code> protected member. Logging not only displays the message on backend's host console, but also on the frontend. Messages are also stored under the PDB so the user can access any log at any time.</p>"},{"location":"backends/#logging-example","title":"Logging example","text":"<pre><code>MyBackend::MyBackend(int argc, char* argv[]) : mulex::MxBackend(argc, argv)\n{\n    info.log(\"Sending a log to the mxsystem.\");\n    info.warn(\"Sending a warning to the mxsystem.\");\n    info.error(\"Sending an error to the mxsystem.\");\n}\n</code></pre>"},{"location":"backends/#registering-user-functions","title":"Registering user functions","text":"<p>It is not uncommon that in many scenarios the user would want to run a periodic function that checks for any changes on the underlying system. The mx system allows to register functions via the <code>MxBackend::deferExec</code> function.</p>"},{"location":"backends/#template-stdderived_frommxbackend-d-mxbackenddeferexecvoid-dfunc-stdint64_t-delay-0-stdint64_t-interval-0","title":"<code>template &lt;std::derived_from&lt;MxBackend&gt; D&gt; MxBackend::deferExec(void (D::*func)(), std::int64_t delay = 0, std::int64_t interval = 0)</code>","text":"<p>Arguments:</p> <ul> <li> <p><code>func</code> - A method from the derived user backend class to register. Must have a declaration of type <code>void &lt;method&gt;(void)</code>.</p> </li> <li> <p><code>delay</code> - When to first run this function (in milliseconds). Defaults to <code>0</code>: run as soon as possible inside the backend event loop thread. Similar to <code>setTimeout(func, 0)</code> in javascript.</p> </li> <li> <p><code>interval</code> - What interval to run this function on (in milliseconds). Defaults to <code>0</code>: run only once. <code>interval</code> does not account for the function's self time.</p> </li> </ul> <p>Functions that share any data and only run via the <code>deferExec</code> call don't require data locking (as long as the data is only used within this context ), as the functions all run on the same thread.</p> <p>Here is an example registering/deffering functions:</p> <pre><code>void global_func()\n{\n    // Cannot access any context here.\n}\n\nclass MyBackend : public mulex::MxBackend\n{\npublic:\n    MyBackend(int argc, char* argv[]) : mulex::MxBackend(argc, argv)\n    {\n        // periodic_data will run every second on this backend\n        deferExec(&amp;MyBackend::periodic_data, 0, 1000);\n\n        // oneshot will run at least 100ms after this call\n        deferExec(&amp;MyBackend::oneshot, 100);\n\n        // non-method will run as soon as possible\n        deferExec(&amp;global_func);\n    }\n\n    void oneshot()\n    {\n        log.info(\"Running after 100 ms.\");\n    }\n\n    void periodic_data()\n    {\n        log.info(\"Dummy periodic.\");\n    }\n};\n</code></pre> <p>Registering non-method functions is also allowed. But you don't have access to the context (i.e. cannot use <code>rdb</code>, <code>log</code>, ...).</p> <p>However, <code>deferExec</code> is public. This is intended for when the backend is of a polling or software trigger type that might be controlled by an external API. E.g.:</p> <pre><code>// Not thread-safe nor keeping the data lifetime\n// Just here to illustrate\nvoid* data = 0;\nint data_len = 0;\n\nvoid my_func(/* api specific args, e.g. */void* api_data, int api_data_len, void* userdata)\n{\n    MyBackend* bck = reinterpret_cast&lt;MyBackend*&gt;(userdata);\n\n    // Something else happens ... API code ... etc ...\n\n    // The API just triggered, we could for example\n    // save the data somewhere and access it on the onExternalAPITrigger\n    // method\n    data = api_data;\n    data_len = api_data_len;\n    // deferExec is thread-safe\n    bck-&gt;deferExec(&amp;MyBackend::onExternalAPITrigger);\n}\n\nclass MyBackend : mulex::MxBackend\n{\npublic:\n    MyBackend(int argc, char* argv[]) : mulex::MxBackend(argc, argv)\n    {\n        // ...\n        registerEvent(\"externalAPI_data\");\n    }\n\n    void onExternalAPITrigger()\n    {\n        log.info(\"ExternalAPIFuncRegisterCallback triggered.\");\n        // Access data somehow ... Do some work ...\n\n        // Or, e.g., dispatch an event\n        dispatchEvent(\"externalAPI_data\", data, data_len);\n    }\n};\n\nint main(int argc, char* argv[])\n{\n    MyBackend bck(argc, argv);\n    bck.init();\n\n    ExternalAPIFuncRegisterCallback(my_func, &amp;bck /* as user data e.g. */);\n\n    bck.spin();\n\n    return 0;\n}\n</code></pre>"},{"location":"backends/#registering-the-user-rpc-function","title":"Registering the user RPC function","text":"<p>There can only be one user RPC function. However it can be changed at runtime. This function is called whenever any context (backend or plugin) calls the <code>BckCallUserRpc</code> for this given backend. Here is a very simple example including frontend code that calls the user RPC:</p>"},{"location":"backends/#backend","title":"Backend","text":"<pre><code>MyBackend::MyBackend(int argc, char* argv[]) : mulex::MxBackend(argc, argv)\n{\n    registerUserRpc(&amp;MyBackend::my_rpc);\n}\n\n// This signature is required\nmulex::RPCGenericType MyBackend::my_rpc(const std::vector&lt;std::uint8_t&gt;&amp; data)\n{\n    log.info(\"User RPC called with data len: %llu.\", data.size());\n    log.info(\"Got: %d.\", reinterpret_cast&lt;std::int32_t*&gt;(data.data()));\n    return 3.1415f;\n    // return {}; if no return is required\n}\n</code></pre> <p> Each backend can only have one user RPC function.</p> <p> You can, however, implement custom logic to branch to multiple other functions.</p>"},{"location":"backends/#frontend","title":"Frontend","text":"<p> The frontend cannot register user RPC functions.</p>"},{"location":"backends/#calling-the-user-rpc-function","title":"Calling the user RPC function","text":""},{"location":"backends/#backend_1","title":"Backend","text":"<pre><code>void MyBackend::any_function()\n{\n    // Calling above 'my_rpc' function as example\n    auto [status, ret] = callUserRpc&lt;double&gt;(\"backend_name\", CallTimeout(1000), std::int32_t(42));\n    // status is BckUserRpcStatus::OK if call succeeded\n    if(status == BckUserRpcStatus::OK)\n    {\n        log.info(\"Got %lf from 'user_rpc' at '&lt;backend_name&gt;'.\", ret);\n    }\n\n    // If function was void omit template arguments\n    string32 other_arg = \"hello\";\n    auto status = callUserRpc(\"other_backend\", CallTimeout(1000), other_arg);\n}\n</code></pre> <p>The example is pretty self explanatory. Take in mind that the arguments passed via template pack need to be trivially copyable and default constructible (alternatively wrap them on a <code>RPCGenericType</code>). <code>CallTimeout</code> specifies the time to wait (in milliseconds) for a response from the other backend. Assign this according to your needs.</p>"},{"location":"backends/#frontend_1","title":"Frontend","text":"<pre><code>const rpc = MxRpc.Create();\nrpc.then(async (handle) =&gt; {\n    const res: MxGenericType = await handle.BckCallUserRpc([\n        MxGenericType.str32('my_backend'),  // Executable name (as listed in home page)\n        MxGenericType.int32(42, 'generic'), // Custom data\n        MxGenericType.int64(10000)          // Timeout in ms\n    ]);\n\n    const [status, retval] = res.unpack(['uint8', 'float32'])[0];\n    // status - status of the call\n    // retval - 3.1415\n});\n</code></pre> <p>The call status is based on the following enum: <pre><code>enum class BckUserRpcStatus : std::uint8_t\n{\n    OK,\n    EMIT_FAILED,\n    RESPONSE_TIMEOUT,\n    NO_SUCH_BACKEND\n};\n</code></pre></p> <p>If no return type is needed it is recommended to return an empty <code>MxGenericType</code> (i.e. <code>return {};</code>). You can also bundle multiple data with the help of the <code>MxGenericType.makeData</code> and <code>MxGenericType.concatData</code> functions.</p> <p><pre><code>const rpc = MxRpc.Create();\nrpc.then((handle) =&gt; {\n\n    const data = MxGenericType.concatData([\n        MxGenericType.int8(42),\n        MxGenericType.f32(3.141592654)\n    ]);\n\n    const res: MxGenericType = await handle.BckCallUserRpc([\n        MxGenericType.str32('my_backend'),       // Executable name (as listed in home page)\n        MxGenericType.makeData(data, 'generic'), // Custom data\n        MxGenericType.int64(10000)               // Timeout in ms\n    ]);\n\n    //...\n});\n</code></pre> Of course proper data handling must take place at the backend user function.</p> <p>The plugin containing this code will call the backend user rpc function as long as it is connected to the mx system.</p>"},{"location":"backends/#setting-dependencies","title":"Setting dependencies","text":"<p>It will often happen that some backends require other backends to properly function. This is where the <code>registerDependency</code> function comes in. It allows you to specify that this backend relies on some other to properly function. This also can come in handy if one would want to write a startup script, it could be done via a \"composer\" backend that orchestrates the startup of the system's critical elements.</p> <pre><code>MyBackend::MyBackend(int argc, char* argv[]) //...\n{\n    // This would terminate this backend if &lt;other_backend_name&gt; failed to start/was not running\n    // The `required()` function if true, tries to remotely start the backend if found\n    registerDependency(\"other_backend_name\").required(true).onFail(RexDependencyManager::TERMINATE);\n\n    // Also works via cid\n    // Only warn if the depency is not found/running\n    // Do not try to start it up (`required(false)`)\n    registerDependency(0xc6a4a7935bd1e995).required(false).onFail(RexDependencyManager::LOG_WARN);\n}\n</code></pre> <p> Dependency checking occurs at the time of expression evaluation but  the backend still runs its i/o loop for at least once before terminate is called. Do not rely on this feature to terminate the backend consistently.</p>"},{"location":"backends/#writing-run-files","title":"Writing run files","text":"<p>If you want to make a file produced from a backend available (registered to the run log), you can upload files to the server. As long as a run is in the <code>RUNNING</code> state anywhere from a backend. This file becomes available in the Run Panel page on the frontend. You may also call this function from the backend registered run start and stop functions.</p> <pre><code>void MyBackend::some_method()\n{\n    std::vector&lt;std::uint8_t&gt; buffer;\n    // ...\n    logRunWriteFile(\"my_file.txt\", buffer);\n}\n</code></pre>"},{"location":"backends/#setting-custom-arguments","title":"Setting custom arguments","text":"<p>Let's say you want to add some custom argument as to where some config file is and don't want to use the RDB/PDB for that. The backend executable accepts custom arguments. They can be added via the <code>SysAddArgument</code> function. It must be called before the constructor of <code>MxBackend</code>. Here's an example:</p> <pre><code>int main(int argc, char* argv[])\n{\n    SysAddArgument(\"my-arg-kebab-case\", 0, true,\n                   [](const std::string&amp; value){ mulex::LogDebug(\"Got arg value: %s\", value.c_str()); },\n                   \"My argument help text.\");\n    MyBackend bck(argc, argv);\n    // ...\n    return 0;\n}\n</code></pre>"},{"location":"backends/#setting-custom-status","title":"Setting custom status","text":"<p>The <code>MxBackend</code> interface allows you to set a custom status that will appear on the project's frontend page. This is usefull to quickly the state of a backend to the user. Here's how to do it:</p> <p><pre><code>void MyBackend::some_method()\n{\n    // ...\n    // Status name followed by a custom RGB triplet\n    setStatus(\"MyCustomStatus\", \"#ff0000\");\n}\n</code></pre> The custom status is reset upon backend disconnect / exit.</p>"},{"location":"events/","title":"Events","text":""},{"location":"events/#summary","title":"Summary","text":"<p>Events are the primary method of transfering large ammounts of data between the backends (and plugins if necessary, but usually just for inspection/online displaying data). They are simpler than the RDB as in they don't have storage. Once an event is triggered, it will be sent to all of the backends/plugins that are listening and once the transfer succeeds, all of the data is voided if not saved by the user.</p> <p>This means the data flow is purely one directional and there is no need of a lock/unlock mechanism as there are no data races, the event data is simply copied and sent for all the listening backends/plugins. Events follow a pattern similar to the pub/sub scheme that so many realtime communication frameworks use nowadays.</p> <p>Events have no intrinsic metadata and therefore are treated as binary buffers internally by the mx system. All of the metadata/packing/unpacking should be taken care of by the user under their backends/plugins. For that there are a few constructs that allow for simple manipulation of events.</p>"},{"location":"events/#using-events","title":"Using Events","text":""},{"location":"events/#from-c","title":"From C++","text":"<p>Issueing events is only allowed from the main backend instantiation of the <code>mulex::MxBackend</code> class.</p>"},{"location":"events/#void-mxbackendregistereventconst-stdstring-evt","title":"<code>void MxBackend::registerEvent(const std::string&amp; evt)</code>","text":"<p>Register a new event under the mx system that can be subscribed from any backend/plugin. <code>evt</code> name must be unique. <pre><code>// Under a backend constructor (for example)\nregisterEvent(\"MyBackend::MyEvent\"); // Any valid unique string with size less than 32 bytes works\n</code></pre></p>"},{"location":"events/#void-mxbackenddispatcheventconst-stdstring-evt-const-stduint8_t-data-stduint64_t-size","title":"<code>void MxBackend::dispatchEvent(const std::string&amp; evt, const std::uint8_t* data, std::uint64_t size)</code>","text":""},{"location":"events/#void-mxbackenddispatcheventconst-stdstring-evt-const-stdvectorstduint8_t-data","title":"<code>void MxBackend::dispatchEvent(const std::string&amp; evt, const std::vector&lt;std::uint8_t&gt;&amp; data)</code>","text":"<p>Dispatch event named <code>evt</code> (must be a valid registered event) to the mx system with the given <code>data</code>. <pre><code>// Under a backend context (e.g. periodic)\nvoid MyBackend::periodic()\n{\n    static std::vector&lt;std::uint8_t&gt; buffer(100);\n    buffer.clear();\n\n    // Fill buffer directly and send\n    // Fill buffer ...\n    dispatchEvent(\"MyBackend::MyEvent\", buffer);\n    // Or use the MxEventBuilder helper class\n    dispatchEvent(\"MyBackend::MyEvent\", mulex::MxEventBuilder(buffer)\n        .add(mulex::SysGetCurrentTime())\n        .add(3.14159265358979)\n    );\n    std::this_thread::sleep_for(100ms);\n}\n</code></pre></p>"},{"location":"events/#void-mxbackendsubscribeeventconst-stdstring-evt-evtclientthreadevtcallbackfunc-func","title":"<code>void MxBackend::subscribeEvent(const std::string&amp; evt, EvtClientThread::EvtCallbackFunc func)</code>","text":"<p>Subscribe to a given event present on the mx system. <code>evt</code> must be a valid event name. The function <code>func</code> gets triggered everytime the event <code>evt</code> is emitted. Subscribing to events emitted on the same backend is allowed (although not very useful). The function callback contains the following parameters:</p> <ul> <li><code>const std::uint8_t* data</code> - The event data</li> <li><code>std::uint64_t len</code> - The event data length</li> <li><code>const std::uint8_t* udata</code> - Custom user data pointer</li> </ul> <pre><code>// For example subscribe on run start\nvirtual void MyBackend::onRunStart(std::uint64_t runno) override\n{\n    subscribeEvent(\"MyBackend::MyEvent\", [/*No lambda capture allowed.*/](auto* data, auto len, auto* udata) {\n        mulex::LogTrace(\"Got event with len: %llu\", len);\n        // Destructure the data synchronously here or copy if processing the event is costly\n    });\n}\n</code></pre>"},{"location":"events/#void-mxbackendunsubscribeeventconst-stdstring-evt","title":"<code>void Mxbackend::unsubscribeEvent(const std::string&amp; evt)</code>","text":"<p>Unsubscribe from the <code>evt</code> event. <pre><code>virtual void MyBackend::onRunStop(std::uint64_t runno) override\n{\n    unsubscribeEvent(\"MyBackend::MyEvent\"); // Unsubscribe from this event on run stop\n}\n</code></pre></p>"},{"location":"events/#from-typescript","title":"From Typescript","text":"<p>The <code>MxEvent</code> object provides access to events for the typescript interface. You cannot emit nor register events from the frontend plugins.</p>"},{"location":"events/#public-mxeventconstructorname-string-mxevent","title":"<code>public MxEvent.constructor(name: string) : MxEvent</code>","text":"<p>Create an event handler to valid/registered event <code>name</code>. <pre><code>const my_event_my_bck = new MxEvent('MyBackend::MyEvent');\n</code></pre></p>"},{"location":"events/#public-set-mxeventonmessagefunc-mxeventcallback","title":"<code>public set MxEvent.onMessage(func: MxEventCallback)</code>","text":"<p>Set the callback for the given event. This is functionally equivalent to subscribing to the event using the C++ API. The function callback contains the following parameters:</p> <ul> <li><code>data: Uint8Array</code> - The event data</li> </ul> <pre><code>my_event_my_bck.onMessage = (data: Uint8Array) : void =&gt; {\n    console.log('Received event data with len ', data.length);\n};\n</code></pre>"},{"location":"events/#public-get-mxeventname","title":"<code>public get MxEvent.name()</code>","text":"<p>Get the current event registered name.</p>"},{"location":"events/#note-on-unsubscribing","title":"Note on unsubscribing","text":"<p>Unsubscribing on the frontend is automatically managed once the <code>MxEvent</code> object goes out of scope and gets handled by javascript's garbage collector.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#running-the-server","title":"Running the server","text":"<p>Mulex-fk manages all of the backends/frontends via the <code>mxmain</code> server service. You can start it with a new test experiment via <pre><code>mxmain -n testexp -l\n</code></pre> This opens the server with an experiment named testexp and in loopback mode so we don't serve the page on the network.</p>"},{"location":"getting_started/#web-frontend","title":"Web frontend","text":"<p>If the previous step is successful you can go to your browser and type <pre><code>localhost:8080\n</code></pre> to land on the frontend home page.</p>"},{"location":"getting_started/#home-page","title":"Home page","text":"<p>This page displays most of the info on currently active backends and connected frontends. There is a 'log panel' where you will be able to see messages from the connected backends (more on this later), a status pane where you see the current 'run' and status, as well as controlling start/stop. It also has a small widget to display system resources.</p>"},{"location":"getting_started/#project-page","title":"Project page","text":"<p>Next is the project page. This will be empty and is where all of the user pages (plugins as called in the API) will be to control the experiment in question.</p>"},{"location":"getting_started/#rdb-page","title":"RDB page","text":"<p>The RDB page allows the connected user to view all of the keys currently present in the system. You can use the top search bar to look for a specific entry. This page also allows for the user to create a new key. Try clicking on a table key entry, the window view will be scrolled down to a pane where all of the current variable info is. This pane updates in realtime. You can for example look under <code>/system/metrics/cpu_usage</code>. This page also allows to edit/remove existing keys (as long as they're not system keys).</p> <p>More on the RDB here.</p>"},{"location":"getting_started/#history-page","title":"History page","text":"<p> This page is still a work in progress.</p> <p>The history page allows you to look at one/multiple RDB entry/entries and log its/their value in a line plot.</p>"},{"location":"getting_started/#creating-backends","title":"Creating Backends","text":"<p>When installing all of the <code>Mx&lt;Lib&gt;.a</code> files will be installed alongside with their header files. Cmake's <code>find_package</code> is able to retrieve include directories and library paths automatically. It becomes trivial to create a backend project with CMake when mulex is installed in the compiling system.</p>"},{"location":"getting_started/#sample-cmakeliststxt-for-a-backend-project","title":"Sample <code>CMakeLists.txt</code> for a backend project","text":"<pre><code>cmake_minimum_required(VERSION 3.10)\nproject(MyBackendProject VERSION 1.0.0)\n\nadd_executable(MyBackend\n    main.cpp\n)\n\nfind_package(MxBackend REQUIRED)\ntarget_link_libraries(MyBackend PRIVATE Mx::MxBackend)\n</code></pre> <p>That simple!</p>"},{"location":"getting_started/#your-first-backend","title":"Your first backend","text":"<p>Under the <code>main.cpp</code> you then create a backend class extending MxBackend.</p> <p><pre><code>using namespace mulex;\n\nclass MyBackend : public MxBackend\n{\npublic:\n    MyBackend(int argc, char* argv[]) : MxBackend(argc, argv)\n    {\n        log.info(\"Hello from MyBackend!\");\n        deferExec(&amp;MyBackend::periodic, 0, 1000); // Run every 1000 ms, starting now\n        registerRunStartStop(&amp;MyBackend::onRunStart, &amp;MyBackend::onRunStop);\n    }\n\n    void onRunStart(std::uint64_t runno)\n    {\n        log.info(\"MyBackend seen run start %llu.\", runno);\n    }\n\n    void onRunStop(std::uint64_t runno)\n    {\n        log.info(\"MyBackend seen run stop %llu.\", runno);\n    }\n\n    void periodic()\n    {\n        log.info(\"MyBackend looping periodic...\");\n    }\n};\n</code></pre> Afterwards just start its event loop on your main.</p> <pre><code>int main(int argc, char* argv[])\n{\n    MyBackend backend(argc, argv);\n    backend.init();\n    backend.spin();\n    return 0;\n}\n</code></pre> <p>That's it! You just created your first mulex backend! Try and run it via <code>./MyBackend --server localhost</code> if you have a running instance of the mulex server running. Now check out what happens on the frontend webapp.</p> <p>You can kill backend instances via the <code>SIGINT</code> signal on Linux (via console <code>Ctrl-C</code>) or on windows on terminal close (also available via <code>Ctrl-C</code>). This will disconnect and close the <code>MyBackend</code> instance smoothly.</p>"},{"location":"getting_started/#creating-frontend-plugins","title":"Creating frontend Plugins","text":""},{"location":"getting_started/#your-first-plugin","title":"Your first plugin","text":"<p>To create a plugin workspace there is the helper command <code>mxplug</code> installed alongside mulex. It allows you to create a new plugin workspace on a given directory. To create a new plugin workspace go to an empty directory and type <pre><code>mxplug --new\n</code></pre> This command creates a simple plugin template for you to populate. To compile it use any node package tool. I like <code>yarn</code> so will be using it but you will be able to replace it with your own in the future. To compile just run (requires yarn) <pre><code>mxplug --build &lt;experiment_name&gt;\n</code></pre> under the plugin root directory.</p> <p>This will build and install (copy) the compiled javascript plugin to the experiment cache folder. Typically</p> <ul> <li><code>/home/&lt;user&gt;/.mxcache/&lt;exp_name&gt;/plugins/</code> on Linux</li> <li><code>%LocalAppData%/mxcache/&lt;exp_name&gt;/plugins/</code> on Windows</li> </ul> <p>Reload the frontend page. Navigate to the project page and look at the new plugin.</p> <p>That's it! You just created your first mulex frontend plugin!</p> <p>This completes the quick start tutorial. For more info check the rest of the documentation on plugins and backends.</p>"},{"location":"installing/","title":"Instalation","text":"<p>Mulex-fk server works under Linux (Windows under testing). The backend API works both under Windows and Linux. Pre-compiled releases are available under the releases tab of the github repository. However, if you wish to have more control/compile for a different ABI/platform here are the steps to build from source.</p>"},{"location":"installing/#requirements","title":"Requirements","text":"<p>To install mulex-fk you will need:</p> <ul> <li>cmake (&gt;= 3.10)</li> <li>gcc/g++ (tested under v12.3.0)</li> <li>python3 (&gt;= 3.10)</li> <li>node.js (tested under v20.12.2)</li> <li>yarn (any node package manager will do with a bit of changing on the <code>CMakeLists.txt</code>)</li> <li>zlib</li> <li>libuv</li> <li>libusb (optional - if you wish builtin USB support on the backends)</li> </ul> <p>Additional libraries are installed under the cmake configuration step and an internet connection is required for the first configuration.</p>"},{"location":"installing/#building","title":"Building","text":"<p>Under the repository main directory (you can look under the main <code>CMakeLists.txt</code> file for additional configure time options): <pre><code>mkdir build &amp;&amp; cmake -DCMAKE_BUILD_TYPE=Release ..\n</code></pre></p> <p> If the configuration step fails at the <code>yarn build</code> go to <code>frontend/</code> and run <code>yarn</code> without arguments to download dependencies.</p> <p>After this just call your prefered build tool and install (e.g. using make): <pre><code>make -j8 &amp;&amp; make install\n</code></pre></p> <p> Installing might require sudo/administrative rights</p> <p>If everything was configured properly you should now be able to type: <pre><code>mxmain --help\n</code></pre> This completes the installation of mulex-fk on the system.</p>"},{"location":"pdb/","title":"PDB","text":""},{"location":"pdb/#summary","title":"Summary","text":"<p>The Persistent DataBase (PDB) is a simple wrapper around a SQLite database present on the mx system. The user is free to access this database and store long term on it if necessary.</p>"},{"location":"pdb/#using-the-pdb","title":"Using the PDB","text":"<p>As of the current version the PDB is only accessible via backends, using the C++ API. On the <code>mulex::MxBackend</code> context there is a <code>pdb</code> field to access a <code>mulex::PdbAccessRemote</code> class.</p>"},{"location":"pdb/#bool-pdbaccesscreatetableconst-stdstring-table-const-stdinitializer_liststdstring-spec","title":"<code>bool PdbAccess::createTable(const std::string&amp; table, const std::initializer_list&lt;std::string&gt;&amp; spec)</code>","text":"<p>Create a table named <code>table</code> under the main database for the experiment. <code>spec</code> is a list of all the modifiers given to the database columns, i.e.:</p> <pre><code>// Within MxBackend context\npdb.createTable(\n    \"mytable\",\n    {\n        \"id INTEGER PRIMARY KEY AUTOINCREMENT\",\n        \"value TEXT NOT NULL\"\n    }\n);\n</code></pre>"},{"location":"pdb/#templatepdbvariable-vs-stdfunctionboolconst-stdoptionalvs-getwriterconst-stdstring-table-const-stdinitializer_liststdstring-names","title":"<code>template&lt;PdbVariable... Vs&gt; std::function&lt;bool(const std::optional&lt;Vs&gt;&amp;...)&gt; getWriter(const std::string&amp; table, const std::initializer_list&lt;std::string&gt;&amp; names)</code>","text":"<p>Returns a writter function for the given table, allowing the user to write to the database. Types need to be specified on the template when calling. <pre><code>auto writer = pdb.getWriter&lt;int, PdbString&gt;(\"mytable\", {\"id\", \"value\"});\n\n// Now we can write in the table\n// std::nullopt is the equivalent of NULL in SQL here and since id is AUTOINCREMENT\nwriter(std::nullopt, \"mystring\");\nwriter(std::nullopt, \"another column\");\n</code></pre></p>"},{"location":"pdb/#templatepdbvariable-vs-stdfunctionstdvectorstdtuplevsconst-stdstring-getreaderconst-stdstring-table-const-stdinitializer_liststdstring-names","title":"<code>template&lt;PdbVariable... Vs&gt; std::function&lt;std::vector&lt;std::tuple&lt;Vs...&gt;&gt;(const std::string&amp;)&gt; getReader(const std::string&amp; table, const std::initializer_list&lt;std::string&gt;&amp; names)</code>","text":"<p>Returns a reader function for the given table, allowing the user to read from the database. Types need to be specified on the template when calling. <pre><code>auto reader = pdb.getReader&lt;int, PdbString&gt;(\"table0\", {\"id\", \"value\"});\n\n// Get id 3\nauto values = reader(\"WHERE id = 3\"); // The reader function accepts conditions formatted SQL style\nauto [id, value] = values[0];\n\n// Get all ids\nauto avalues = reader();\nauto [id0, value0] = avalues[0];\nauto [id1, value1] = avalues[1];\n// ...\n</code></pre></p>"},{"location":"plugins/","title":"Plugins","text":""},{"location":"plugins/#summary","title":"Summary","text":"<p>Plugins are standalone javascript/typescript modules that contain GUI's made by the user to control/display available data.</p> <p>From these pages, the use as access to the typescript mulex API and can control:</p> <ul> <li>RDB variables</li> <li>PDB tables</li> <li>Subscribe to events</li> <li>Plot data via 'uplot' wrapper</li> <li>Create control interfaces with buttons/comboboxes/value selections/switches/etc...</li> <li>Make RPC calls to the server</li> <li>Make user RPC calls to the user's backends</li> <li>Write any compliant typescript code to perform whatever task necessary</li> </ul> <p>A simple way to get started is to look under the demo plugin shipped with mxplug. To do so, simply run <code>mxplug --new</code> on an empty directory and inspect the <code>src/entry/plugin.tsx</code> entry file.</p> <p>The API specification for each topic above is explained under each section on the sidebar and will not be present here. This page focus more on the layout of the plugin directory and how to build/create plugins.</p>"},{"location":"plugins/#project","title":"Project","text":"<p>A plugin is just a typical solid-js project. To learn more about the solid-js framework view here. Here is a brief description of all the files under the plugin project directory:</p> <pre><code>\u251c\u2500\u2500 lib/                    # Contains lib files, typically not used\n\u251c\u2500\u2500 assets/                 # Contains asset files\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib/                # Contains mx lib files, typically not used\n\u2502   \u251c\u2500\u2500 api/                # Contains mx api files, typically not used\n\u2502   \u251c\u2500\u2500 components/         # Contains mx component files\n\u2502   \u2514\u2500\u2500 entry/              # Contains the plugin entry point files\n\u2502       \u251c\u2500\u2500 plugin1.tsx     # These need to be here for\n\u2502       \u251c\u2500\u2500 plugin2.tsx     # mxplug to know how to build\n\u2502       \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 package.json            # node project package file\n\u251c\u2500\u2500 tsconfig.json           # typescript project specifications\n\u251c\u2500\u2500 vite.config.ts          # vite build specifications\n\u2514\u2500\u2500 globals.d.ts            # global variables that don't need 'import'\n</code></pre> <p>In reality this is simply a typescript project that gets compiled via vite to a working javascript file that gets imported by the mx server. The only difference being the project tree is already cooked to work with our solid-js framework and mx ts API.</p> <p>All the <code>.tsx</code> files under <code>src/entry/</code> will be treated as input files for building standalone plugins. So each file here represents one page/plugin on the server project page. The location of your other files is not mandatory. They can be placed anywhere. However, feel free to follow the already existing structure. You should also modify the project metadata under the <code>package.json</code> file.</p>"},{"location":"plugins/#building","title":"Building","text":"<p>To build the project simply type <code>mxplug --build &lt;expname&gt;</code> on the root dir (where <code>package.json</code> is) with <code>&lt;expname&gt;</code> as you experiment running on the mx server. Building uses built in yarn. This is currently not changable so if you wish to use your own manager refer to the getting started page.</p> <p>To use \"dev\" mode (i.e. build when a source file is modified) you can run <code>mxplug</code> in hotswap mode via <code>mxplug --build &lt;expname&gt; --hotswap</code>. This will make the plugin build binary run indefinitely and check for file changes under the specified working directory.</p> <p>To build and copy the files to a remote server you can now use the command with the remote argument: <code>mxplug --build &lt;expname&gt; --remote &lt;host&gt;</code>. This will copy the files to the remote host. The file transfer is not encrypted. Very usefull when the host computer is not were you are developing the plugins.</p>"},{"location":"plugins/#api-elements","title":"API Elements","text":"<p>All the API components are displayed in the demo <code>plugin.tsx</code> file and are pretty simple to use. Head there to check out how to use them.</p>"},{"location":"rdb/","title":"RDB","text":""},{"location":"rdb/#summary","title":"Summary","text":"<p>The Realtime DataBase (RDB) works much like a disk database in the sense it stores data from multiple backends/frontends on a contiguous chunk of data. The only difference being, the RDB lives on system memory directly, making it orders of magnitude faster to store/retreive values.</p> <p>Inside the mx system the RDB is, however, still considered to be a way of storing \"slow\" control/data variables.</p> <p>Much like an SQL database, the RDB allows unrestricted access to all of its variables from all backends/plugins. The only exception being plugins cannot modify/delete <code>/system/*</code> variables. The RDB is based on a key/values access policy, i.e. one key corresponds to one value. Although the keys are presented on a directory fashion (much like a tree) this hirerarchy is only present for eye candy as the real memory layout is flat and there is no real dependency between key \"directories\". Here is an example of how a tiny RDB might look like:</p> <pre><code>\u251c\u2500\u2500 system\n\u2502   \u251c\u2500\u2500 syskey1     # /system/syskey1\n\u2502   \u2514\u2500\u2500 sysdir1     # In reality does not exist\n\u2502       \u251c\u2500\u2500 syskey1 # /system/sysdir1/syskey1\n\u2502       \u2514\u2500\u2500 syskey2 # /system/sysdir1/syskey2\n\u2514\u2500\u2500 user\n    \u251c\u2500\u2500 mykey       # /user/mykey\n    \u2514\u2500\u2500 mydir       # In reality does not exist\n        \u2514\u2500\u2500 mykey2  # /user/mykey2\n</code></pre> <p>Here I used the <code>/user/</code> directory to contain an experiment user keys but in reality you can write (although discouraged) keys directly on root dir or any other named directory (user preference really).</p> <p>Keys are available to all of the backends/plugins as soon as possible and concurrency is allowed and automatically managed (again, much like an SQL database).</p> <p>Although the RDB has a much higher throughput than the typical disk database, it is recommended to use events as the primary method to transfer large/fast chunks of data between fronteds/plugins (\"fast\" control).</p>"},{"location":"rdb/#rdb-view","title":"RDB view","text":"<p>The main webapp page contains a page for inspecting the RDB values in realtime. There you can quickly inspect/create/delete/modify keys and values.</p>"},{"location":"rdb/#using-the-rdb","title":"Using the RDB","text":""},{"location":"rdb/#from-c","title":"From C++","text":"<p>The backend class that extends MxBackend as access to an rdb proxy object, the <code>mulex::RdbAccess</code> class. Named <code>rdb</code> as a protected member. It works much like a <code>std::map</code> in terms of accessing.</p>"},{"location":"rdb/#inline-rdbproxyvalue-rdbaccessoperatorconst-stdstring-key","title":"<code>inline RdbProxyValue RdbAccess::operator[](const std::string&amp; key)</code>","text":"<p>The returned <code>RdbProxyValue</code> allows you to manipulate values. Allows accessing rdb keys remotely. Examples: <pre><code>// Reading\nint key = rdb[\"/user/mykey\"]; // If mykey is an integer\nfloat fkey = rdb[\"/user/myfloatkey\"]; // If mykey is a float\n\n// You can also explitly cast\nauto key = static_cast&lt;int&gt;(rdb[\"/user/mykey\"]);\n\n// Writing\nrdb[\"/user/mykey\"] = 3; // Implicit cast int '/user/mykey' must be int32_t type\nrdb[\"/user/mykey\"] = static_cast&lt;float&gt;(3.14); // Cast float '/user/mykey' must be float type\n</code></pre></p>"},{"location":"rdb/#bool-rdbproxyvalueexists","title":"<code>bool RdbProxyValue::exists()</code>","text":"<p>Checks if the given key exists on the RDB: <pre><code>bool has_key = rdb[\"/user/mykey\"].exists();\n</code></pre></p>"},{"location":"rdb/#bool-rdbproxyvaluecreaterdbvaluetype-type-rpcgenerictype-value-stduint64_t-count-0","title":"<code>bool RdbProxyValue::create(RdbValueType type, RPCGenericType value, std::uint64_t count = 0)</code>","text":"<p>Creates a new key under the provided location with type <code>type</code> and value <code>value</code>. <code>count</code> specifies if the key is an array or not (count zero). This last argument is reserved for future use and must be zero. <pre><code>if(!rdb[\"/user/intkey\"].create(RdbValueType::INT32, std::int32_t(42)))\n{\n    // Failed to create key\n}\n</code></pre></p>"},{"location":"rdb/#bool-rdbproxyvalueerase","title":"<code>bool RdbProxyValue::erase()</code>","text":"<p>Erases the given key: <pre><code>if(!rdb[\"/user/mykey\"].erase())\n{\n    // Failed to erase key, maybe it does not exist?\n}\n</code></pre></p>"},{"location":"rdb/#void-rdbproxyvaluewatchstdfunctionvoidconst-rdbkeyname-key-const-rpcgenerictype-value-callback","title":"<code>void RdbProxyValue::watch(std::function&lt;void(const RdbKeyName&amp; key, const RPCGenericType&amp; value)&gt; callback)</code>","text":"<p>Watch the given key/pattern for changes and trigger <code>callback</code> as a result: <pre><code>rdb[\"/user/mykey\"].watch([&amp;](const RdbKeyName&amp; key, const RPCGenericType&amp; value) {\n    // This callback gets triggered everytime '/user/mykey' changes\n    log.info(\"Key %s changed and now contains value %d.\", key.c_str(), value.asType&lt;std::int32_t&gt;());\n});\n</code></pre> This specific method allows for a <code>RdbProxyValue</code> with a pattern for a key. For example: <pre><code>rdb[\"/user/*\"].watch([&amp;](const RdbKeyName&amp; key, const RPCGenericType&amp; value) {\n    // This callback gets triggered everytime any key under the '/user' directory changes\n    log.info(\"Key %s changed and now contains value %d.\", key.c_str(), value.asType&lt;std::int32_t&gt;());\n});\n</code></pre> Valid patterns example:</p> <ul> <li><code>/*</code></li> <li><code>/*/*</code></li> <li><code>/dir/*/dir2/key</code></li> <li><code>/dir/*/dir2/*</code></li> </ul> <p>Invalid patterns example:</p> <ul> <li><code>*</code></li> <li><code>/*sub/*</code></li> <li><code>/dir/*/dir2/key*suffix</code></li> </ul>"},{"location":"rdb/#void-rdbproxyvalueunwatch","title":"<code>void RdbProxyValue::unwatch()</code>","text":"<p>Unwatch key on a given <code>RdbAccess</code> instance: <pre><code>rdb[\"/user/mykey\"].unwatch(); // Stop watching this key\n</code></pre></p>"},{"location":"rdb/#void-rdbproxyvaluehistorybool-status","title":"<code>void RdbProxyValue::history(bool status)</code>","text":"<p>Enable/disable variable history logging. This feature, when enabled, logs all the changes the given variable went into the persistent database (PDB). This feature is still a work in progress. <pre><code>rdb[\"/user/mykey\"].history(true); // Log this variable for the foreseeable future\n</code></pre></p>"},{"location":"rdb/#from-typescript","title":"From Typescript","text":"<p>Accessing the rdb from plugins via Typescript is similar to C++. It is performed using the <code>MxRdb</code> class.</p>"},{"location":"rdb/#public-async-mxrdbcreatekey-string-type-string-value-any-count-number-0-promisevoid","title":"<code>public async MxRdb.create(key: string, type: string, value: any, count: number = 0) : Promise&lt;void&gt;</code>","text":"<p>Create a key. <pre><code>const rdb = new MxRdb();\nrdb.create('/user/mykey', 'int32', 42);\n</code></pre></p>"},{"location":"rdb/#public-mxrdbdeletekey-string-void","title":"<code>public MxRdb.delete(key: string) : void</code>","text":"<p>Delete a key. <pre><code>const rdb = new MxRdb();\nrdb.delete('/user/mykey');\n</code></pre></p>"},{"location":"rdb/#public-async-mxrdbreadkey-string-promiseany","title":"<code>public async MxRdb.read(key: string) : Promise&lt;any&gt;</code>","text":"<p>Read a key. Unlike its C++ counterpart, this function does not require the variable type. It is automatically inferred. <pre><code>const rdb = new MxRdb();\nconst value : number = rdb.read('/user/mykey'); // If we know it is a number (for example int32)\n</code></pre></p>"},{"location":"rdb/#public-async-mxrdbwritekey-string-value-any-promisevoid","title":"<code>public async MxRdb.write(key: string, value: any) : Promise&lt;void&gt;</code>","text":"<p>Write a key. Unlike its C++ counterpart, this function does not require the variable type. It is automatically inferred. <pre><code>const rdb = new MxRdb();\nrdb.write('/user/mykey', 42); // If we know it is a number (for example int32)\n</code></pre></p>"},{"location":"rdb/#public-mxrdbwatchkey-string-callback-function-void","title":"<code>public MxRdb.watch(key: string, callback: Function) : void</code>","text":"<p>Watch a key/pattern for changes (Patterns are the same as for the C++ API). <pre><code>const rdb = new MxRdb();\nrdb.watch('/user/mykey', (key: string, value: MxGenericType) =&gt; {\n    console.log('Key ', key, ' changed and now contains value ', value.astype('int32'));\n});\n</code></pre></p>"},{"location":"rdb/#public-mxrdbunwatchkey-string-void","title":"<code>public MxRdb.unwatch(key: string) : void</code>","text":"<p>Unwatch a key on the current <code>MxRdb</code> instance. <pre><code>const rdb = new MxRdb();\n//...\nrdb.unwatch('/user/mykey');\n</code></pre></p>"},{"location":"rex/","title":"REX","text":""},{"location":"rex/#summary","title":"Summary","text":"<p>The mxrexs (remote execution service - Rex for short) is a small background service that quietly runs on the system providing backend remote start/stop capabilities.</p>"},{"location":"rex/#running-rex","title":"Running rex","text":"<p>You can run rex two ways: inplace and daemon. Running rex as a daemon is recommended (contrary to backends, this workds both on Linux and Windows).</p> <p>To simply run rex on the current console type <code>mxrexs</code>. That's it, nothing else required, just leave the process up. Otherwise it is recommended to run rex on the background via <code>mxrexs --start</code> (stop it using <code>mxrexs --stop</code>).</p> <p>Once rex is running, any local backend that has been started in the past is known to rex and is able to be started/stopped via RPC call. Since this is a RPC call one can start backends via:</p> <ul> <li>Browser</li> <li>Other backends on same system</li> <li>Other backends on other system</li> </ul> <p>The recommended easy way to make rex always available is to put its executable on a system service (systemd on Linux, taskscheduler on Windows) with auto-start on computer wake-up.</p>"},{"location":"rex/#startingstopping-backends-remotely","title":"Starting/Stopping Backends Remotely","text":"<pre><code>MX_RPC_METHOD mulex::RexCommandStatus RexSendStartCommand(std::uint64_t backend);\nMX_RPC_METHOD mulex::RexCommandStatus RexSendStopCommand(std::uint64_t backend);\n</code></pre> <p>To start/stop a backend remotely use the aforementioned RPC calls.</p>"}]}